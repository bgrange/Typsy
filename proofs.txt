NAME:Ben Grange
LOGIN:bgrange

Part 2, Assignment #4, COS 326
------------------------------



Part 2.1:
--------

Prove that for all a, b, c : complex,

cadd a (cadd b c) == cadd (cadd a b) c

Proof:
Since a,b and c are of type complex, we may assume that

		a == (xa,ya)			(definition)
		b == (xb,yb)
		c == (xc,yc)

Now to show that: 
  cadd (xa,ya) (cadd (xb,yb) (xc,yc)) == cadd (cadd (xa,ya) (xb,yb)) (xc,yc)

(1)		cadd (xa,ya) (cadd (xb,yb) (xc,yc))	(LHS)

(2) 	==	let (x1,y1) = (xa,ya)  in		(eval cadd)
		let (x2,y2) = (cadd (xb,yb) (xc,yc)) in
		(x1+x2,y1+y2)

(3) 	==	let (x1,y1) = (xa,ya) in		(eval cadd, subst)
		let (x2,y2) =
		  let (w1,z1) = (xb,yb) in
		  let (w2,z2) = (xc,yc) in
		  (w1+w2,z1+z2)
		in
		(x1+x2,y1+y2)

(4) 	==	let (x1,y1) = (xa,ya) in
		let (x2,y2) = (xb+xc,yb+yc) in		(eval let, subst)
		(x1+x2,y1+y2)

(5) 	==	(xa+(xb+xc),ya+(yb+yc))			(eval let)

	==	((xa+xb)+xc,(ya+yb)+yc)			(associativity of +,
							subst)

(6)	==	cadd (cadd (xa,ya) (xb,yb)) (xc,yc)	(reverse eval cadd
							same as (1) - (5))

Part 2.2: 
---------

Prove that for all integer lists xs and ys,
max (maxs xs) (maxs ys) == (maxs (append xs ys)).

Clearly justify each step of your proof.

Proof:  By induction on the structure of the list xs.

case xs == []:

To show:
	For any ys
	max (maxs []) (maxs ys) == (maxs (append [] ys))

Proof:
		max (maxs []) (maxs ys)		(LHS)

(1)	==	max min_int (maxs ys)		(eval maxs [])

(2)	==	maxs ys				(min_int)

(3)	==	max (append [] ys)		(reverse eval append [] ys)


case xs == hd::tail:

IH: max (maxs tail) (maxs ys) == maxs (append tail ys)

To show:
	For any ys 
	max (maxs hd::tail) (maxs ys) == (maxs (append hd::tail) ys)

Proof:
		max (maxs hd::tail) (maxs ys)		(LHS)

(1)	==	max (max hd (maxs tail)) (maxs ys)	(eval maxs hd::tail,
							 substitution)

(2)	==	max hd (max (maxs tail) (maxs ys))	(associativity)

(3)	==	max hd (maxs (append tail ys))		(IH and substitution)

(4)	==	maxs (hd::(append tail ys))		(reverse eval maxs,
							 substitution)

(5)	==	maxs (append (hd::tail) ys)		(reverse eval append,
							 substitution)

QED!

Part 2.3: 
---------

(a) Prove that for all integer lists l, bump1 l == bump2 l.

Proof:
Let l be an arbitrary list

	bump1 l			(LHS)

==	map (fun x -> x+1) l	(eval bump1 l)

==	match l with		(reverse eval map)
	  [] -> []
	| hd::tl -> ((fun x -> x+1) hd) :: tl

==	match l with		(eval (fun x -> x+1) hd,
	  [] -> []		 substitution)
	| hd::tl -> (hd+1) :: tl

==	bump2 l			(reverse eval bump2 l)

QED


(b) Prove that for all integer lists l, bump1 l == bump3 l.

Proof: I proceed by induction in two parts.

Case 1: l == []
To show: bump1 [] == bump3 []

		bump1 []		(LHS)

(1)	==	map (fun x -> x+1) []	(eval bump1 [])

(2)	==	match [] with		(eval map)
		  [] -> []
		| hd::tl -> ...

(3)	==	[]			(eval match statement)

(4)	==	match [] with		(reverse eval match statement)
		  [] -> []
		| hd::tl -> (hd+1) :: (bump3 tl)

(5)	==	bump3 []		(reverse eval bump3 [])


Case 2: l = hd::tl

To show: bump1 (hd::tl) == bump3 (hd::tl)
IH: bump1 tl == bump3 tl

		bump1 (hd::tl)					(LHS)

(1)	==	map (fun x -> x+1) (hd::tl)			(eval bump1)

(2)	==	((fun x -> x+1) hd) :: (map (fun x -> x+1) tl)	(eval map)

(3)	==	(hd+1) :: (bump1 tl)		(eval anonymous function, 
					 	reverse eval bump1,
					 	substitution)

(4)	==	(hd+1) :: (bump3 tl)			(IH, substitution)

(5)	==	bump3 (hd::tl)			(reverse eval bump3)

QED


(c) In one sentence, what's the big difference between parts (a) and (b)?
Basically, bump2 is bump1 "unrolled" one iteration; this proof can be done
without induction because it's only one iteration; whereas bump3 is bump1
unrolled all the way, which necessitates the use of induction.


Part 2.4:
---------

Either prove or disprove each of the following. You will do any proofs using
induction on lists and you will disprove any false statement by providing a
counter-example to the claim.  When you do a proof, be sure to use the 
standard template for list proofs.

(a) For all l : ('a * 'b) list, zip(unzip l) == l.
This statement is true.

Proof:
By induction in two parts.

Case 1: l == []
To show: zip(unzip []) = []

		zip(unzip [])		(LHS)
(1)	==	zip([],[])		(eval unzip [], substitution)
(2)	==	[]			(eval zip)

Case 2: l == (x,y)::tl
To show: zip(unzip ((x,y)::tl)) == (x,y)::tl
IH: zip(unzip(tl)) == tl

		zip(unzip (x,y)::tl)		(LHS)
(1)	==	zip(let xs,ys = unzip tl in	(eval unzip, substitution)
		    (x::xs, y::ys))

(2)	==	(x,y) ::
		(zip (let xs,ys = unzip tl in
		      (xs,ys)))			(reverse eval zip)

(3)	==	(x,y) :: zip(unzip tl)		(eval let, substitution)

(4)	==	(x,y) :: tl			(IH, substitution)

QED


(b) For all l1 : 'a list, l2 : 'b list, unzip(zip (l1,l2)) == (l1,l2).

This statement is not true. If we let l1 = [0] and l2 = [] (or any pair of
lists with different lengths), then zip(l1,l2) == [],
and so unzip(zip(l1,l2)) == unzip([]) == ([],[]) != (l1,l2).
This can easily be verified with the interpreter.
