let type Eq (X::*) =
Typerec Eq [X] :: * of
| Int => Int
| Bool => Bool
| Str => Str
| Void => Void
| S -> T => Void
| S * T => (Eq [S]) * (Eq [T])
| List S => List (Eq [S])
end
in
let not (b:Bool) : Bool = if b then false else true in

let rec fold (A::*) (B::*) (f:A -> B -> B) (base:B) (l:List A) : B =
      match l with
      | nil => base
      | hd::tl => (f hd (fold [A] [B] f base tl)) 
      end
in

let rec eq_list (A::*) (eq_a:A -> A -> Bool) (l1:List A) (l2:List A) : Bool =
    match l1 with
    | nil => match l2 with
             | nil => true
	     | hd::tl => false
	     end
    | hd1::tl1 => match l2 with
                | nil => false
		| hd2::tl2 => eq_a hd1 hd2 && eq_list [A] eq_a tl1 tl2
		end
    end
in
let rec eq (A::*) : Eq [A] -> Eq [A] -> Bool =
  typecase [\\ (D::*) => Eq[D] -> Eq[D] -> Bool] A of
  | Int => (\ (x:Int) (y:Int) => x == y)
  | Bool => (\ (b1:Bool) (b2:Bool) => if b1 then b2 else not b2)
  | Str => (\ (s1:Str) (s2:Str) => false)
  | Void => (\ (v1:Void) (v2:Void) => false)
  | S -> T => (\ (f1:Void) (f2:Void) => false)
  | S * T => (\ (p1:Eq[S*T]) (p2:Eq[S*T]) => eq [S] (fst p1) (fst p2) && eq [T] (snd p1) (snd p2))
  | List S => eq_list [Eq[S]] (eq [S])
  end
in
eq [Int] 23 23
