Surface language with optional types
==> type inference
Explicitly typed syntax

Why do typclasses map to modules WITH sharing constraints?

We want this kind of thing

class Show a =
 show :: a -> String

instance Show Int =
 show x = [SOME FUNCTION OF x]

show 5

to map to

module type Show =
 type t
 val show : t -> string
end

module ShowInt : Show =
 type t = int
 show x = [FUNCTION OF x]
end

################################
Design decisions/questions
################################

Use global variable for gen_var?
For typechecking, rename everything in advance to prevent nameclashes?
Two ways to avoid nameclashes on the fly:
    Rename vars when checking abstraction
    Or rename vars when applying
